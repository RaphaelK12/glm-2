
# *OpenGL Mathematics for C*

[*glm-c*](https://github.com/sizeof-voidp/glm-c) is a C alternative of the C++ library [*glm*](https://github.com/g-truc/glm).
It was made referencing the [*GLSL specification*](https://www.khronos.org/registry/OpenGL/specs/gl/GLSLangSpec.4.60.pdf) as well. This is meant to be used in C11/C17, you could use this no problem in C99/C89 with a smaller feature set though.

### Macros for generating typenames
In *glm-c* you have a few macros which are meant for use as template replacement, they are used to generate typenames.
The common ones are `glm_scalar(T, Q)`, `glm_vec(L, T, Q)` and `glm_mat(C, R, T, Q)`. 
As an example `glm_vec(3, float, defaultp)` would become `glm_vec3` after the preprocessing step.

```c

glm_mat(4, 4, float, highp) m = ...;
glm_vec(4, float, highp) v = ...;

v = glm_mulv_mat4x4_highp(m, v);

```

### Macros for constructing types
Macros for constructing types, these are unique not only to each type, such as `glm_vec4()` and `glm_uint2()`, but they also are defined for each qualifier variant. Except `defaultp` as that can be ignored. These work exactly as *GLSL* constructors but there is both a compile time cost, and run-time cost as it uses C11's `_Generic()` and variadic functions to parse through arguments.

```c
// Construct default precision vector of 3 unsigned integers.
glm_uvec3 co = glm_uvec3('F', 0x47FC, 12.5f);

// You can construct a vector, from another of the same length.
// Effectively all this does is a cast, but it's less direct.
// You can either manually type out the constructor macro's name, or use the
// template-like macro for generating the typename.
// All function-like macros which construct types (constructors), have the same name
// as those types.
glm_uvec3_lowp cp = glm_vec(3, uint, lowp)(co);
```


You can mix and match types, qualifiers, and lengths, just like in *GLSL*.
```c
glm_uvec2 v1 = ...;
glm_bvec2 v2 = ...;

glm_vec4 v = glm_vec4(v1, v2);
```

You can even give the constructor macro more elements than the destination vector.
And so the argument elements will be truncated or excess elements are thrown away.
Note that this is something even the official C++ [*glm*](https://github.com/g-truc/glm) library doesn't do.
```c
glm_float a = ...;
glm_uvec2 b = ...;
glm_bvec3 c = ...;

// Last two elements of `c` get ignored, while the first one is used.
// Again as you can see, you can pass a variety of types and lengths to these macros.
// No problem at all!
glm_ivec4 v = glm_ivec4(a, b, c);
```

You can construct any type from a combination of any other, so you could construct for example
a `glm_vec4` from a `glm_mat2x2`. The following should be perfectly valid. 
```c
glm_mat2x2 m = ...;
glm_vec4 v = glm_vec4(m);
```

### Features

- [x] All 38 *GLSL* types, and their related functions.
- [x] Exact *GLSL* constructor syntax.
- [x] Exact *GLSL* internal function syntax.
- [x] Zero cost swizzling for contiguous combinations of elements. (i.e. xy, gb)
- [x] All 20 *GLSL* vector types.
- [x] All 18 *GLSL* matrix types.
- [ ] Camera helper functions.
- [ ] Quaternions.
- [x] Static asserts for valid code generation.
- [ ] Inline code generated by macros for all types.
- [ ] Swizzling functionality.
- [ ] *FMV* (Function Multi-Versioning) system for run-time optimization.
- [ ] Manually optimize versions of common vector or matrix operations using inline assembly. (Intel SSE, Arm NEON, etc..)
- [ ] Precision Qualifiers.
- [ ] Ability to build *glm-c* as a shared or a static library.
